# Семинар СДП - седмица 4

## Динамичен масив. Proxy

## Шаблонът представител (Proxy design pattern)
Шаблонът представител е шаблон за дизайн, чрез който можем, вместо да работим с оригиналния обект, да работим с обект, "представящ" се за него, който да извършва някакви допълнителни операции при извикването на методите му или при достъпа до член-данните му. Такива операции могат да бъдат например допълнителен контрол до достъпа на данните в обекта, заделяне на памет само при нужда (мързеливо), кеширане, изпълняване на някакви странични ефекти и др. За да може нашият нов обект да се "представи" за оригиниалния обект има два варианта - или новият обект да следва същия интерфейс като оригиниалния, или да може да бъде преобразуван до типа на оригиналния. 

Но защо бихме искали да създаваме нов обект, представящ се за оригиналния, вместо просто да го модифицираме? Отговорът в голяма част от случаите е - защото не можем! Например, може обектът да е част от някаква библиотека, която не можем да модифицираме, или пък методите, които използват обекта, работят само с обекти от конкретния тип. Разбира се можем да използваме шаблонът и като лесен и генеричен начин за добавяне на допълнителна логика, без да се налага създаваме някакви сложни йерархии от класове.

Ето и един пример за представител, който прави допълнителна валидация на член-данните на обекта:
```c++
class Object {
public:
  Object(int a) : a(a) {}

  int get() { return a; }

private:
  int a;
};

class Proxy {
public:
  Proxy(int a) : a(a > 0 ? a : 0) {}
  
  operator Object() {
    return Object(a);
  }

private:
  int a;
};

Object create(int a, int b) { 
  return Proxy(b - a);
}

int main() {
  Object obj1 = create(3, 5);
  Object obj2 = create(5, 3);

  std::cout << obj1.get() << '\n'; // -> 2
  std::cout << obj2.get() << '\n'; // -> 0
  return 0;
}
```

## Bitset (Динамичен масив с булеви елементи)

#### Какво е Bitset?
Bitset е масив от булеви стойности. Както при нормалните масиви имаме статичен и динамичен, но тук ще се занимаваме с динамичния вариант. 

#### Защо е нужен?

Колко памет заема една променлива от тип bool?

Има ли по-оптимален начин да представяме булеви стойности?

#### Как ще имплементираме такава структура с оптимална памет?

Най-малката променлива по памет в C++ заема 1 byte = 8 bit. Следователно в нея могат да се представят 255 различни състояния на променливата. Ако искаме всеки бит да отговаря за различна булева променлива ще ни е нужно да използваме една променлива, като 8 булеви. Ще постигнем това с помощта на побитови операции


#### Преговор на побитови операции

- Побитово И (**&**)
- Побитово ИЛИ  (**|**)
- Побитово НЕ (**~**)
- Побитово ИЗКЛЮЧВАЩО ИЛИ  (**^**)
- Побитово отместване  (**<<** )  ( **>>**)

|a|b|Оператор| Резултат  |
|---|---|--------|-----------|
|10101010|10010111| a & b  | 10000010 |
|10101010|10010111| a \| b | 10111111 |
|10101010|10010111| ~ b    | 01101000 |
|10101010|10010111| a ^ b  | 00111101 |
|10101010|10010111| a << 2 | 10101000 |
|10101010|10010111| a >> 2 | 00101010 |


#### Основни операции, които ще използваме 

1. setTrue(pos)
   - mask = 1 << pos
   - value = value | mask;
2. setFalse(pos)
   - mask = 1 << pos
   - value = value & (~mask);
3. getBit(pos)
   - mask = 1 << pos
   - result = value & mask;
4. invertBit(pos)
   - mask = 1 << pos
   - value = value ^ mask;


#### Носител на информация
За носител на информацията ще използваме 
динамичен масив от тип uint8_t, като всяка променлива ще отговаря за 8 булеви стойности

При заявка за промяна или извличане на информация ще пресметнем кой бит от коя променлива ни е нужен и ще използваме по-горните методи за да извършим съответната операция.


Ще искаме нашата структура да има следната сигнатура:

```cpp
class BitSet{

    BitSet()
    BitSet(size_t size)
    ??? operator[](size_t index);
    void push_back(bool);
    void pop_back();
    size_t size()const;
    void flip();
    void flip(size_t pos);
    bool all()const;
    bool any()const;
    bool none()const;
};
```
<details>
<summary>Подсказка (щракни за разгъване)</summary>

- За BitSet: представи индексът като (byteIndex = i/8, bitIndex = i%8). За set/get използвай маска (1u << bitIndex).
- За operator[] върни proxy обект (BitReference) който има:
    - operator bool() const;
    - BitReference& operator=(bool);
    - евентуално flip()
    Това позволява както присвояване, така и четене: bs[i] = true; if (bs[i]) ...
- Итераторът (RandomAccessIterator) може да държи pointer към BitSet + позиция (size_t pos). Задължителни типове:
    - using iterator_category = std::random_access_iterator_tag;
    - using difference_type = std::ptrdiff_t; using value_type = bool; using reference = BitReference; using pointer = void;
- За multi-bit values (bits_per_value <= 16): използвай шаблонен параметър Bits и като носител uint8_t/uint16_t/uint32_t, пресмятай startBit = index * Bits; прочитай/записвай чрез събиране на съседни байтове, маска и shift. Помисли за неравномерно разпределение през граници на байтове.
</details>

#### Задача:
Да се имплементира Random Access Iterator за структурата поддържащ следните операции:
- оператор *
- postfix и prefix оператори `++` и `--`
- оператори за събиране и изваждане на итератор с число `+`, `+=`, `-=`, `-`
- оператор за разлика между два итератора `-`
- оператори за сравнение: `==`,`!=`,`<`,`>`,`<=`,`>=`
- оператор `[]` 

#### Допълнителна задача 
Какво правим ако искаме да използваме по няколко бита за променлива, а не 1(в случая с булеви стойности)? Например искаме да имаме масив от числа където стойностите са от 0 до 5. Дори ако използваме масив от uint8_t, това са 255 стойности, от които ние ще използваме само 6. Има ли как да модифицираме Bitset-a, така че да пазим повече информация за всяка променлива, а не само 1 бит. За простота нека този размер е <=16 бита за да може резултатът да е от тип uint16_t. Нека новият клас получава в конструктора размера на тези променливи в битове( ако не е зададен нека той да бъде 4).