# Семинар СДП - седмица 3

# Динамична памет. Итератори и работа с файлове.

### I. Динамична памет

#### 1. Stack

- Паметта, която ще се задели, се определя по време на **компилация**.
- Паметта се освобождава автоматично - при излизането от scope-а,  в който е дефинирана.

#### 2. Heap

- От тук се заделя памет по време на **изпълнение** на програмата.
- Масиви и обекти без предварително да е известна големината.
- Паметта продължава да е "заета" дори и след излизане от scope-а.

#### 3. Оператор new

- Връща указтел към началото на паметта, която сме заделили.
- Заделянето на динамична памет е много "**бавна**" операция!!


#### 4. Оператор delete

- Динамична памет **НЕ** се трие автоматично, както в други езици.
- Оператор delete и delete[] - освобождава динамична памет!

### Разпределение на памет 
![](https://study.com/cimages/multimages/16/1f3a8c28-4082-4714-b6fa-6bb81804095b_screen_shot_2017-12-01_at_1.31.10_pm.png)


### II. Итератори

Итератор е шаблон за дизайн, който ни предоставя единен интерфейс за обхождане на елементите на произволни колекции без да се интересуваме от вътрешното представяне на елементите. На практика, итераторът представлява отделна структура, която съхранява единичен елемент от колекцията, която обхожда, като той трябва да "знае" кой е следващият елемент, който трябва да бъде обходен. Ние вече се запознахме с най-простите итератори в курса по Увод в програмирането - това бяха указателите към масиви. Те отговарят на горните 2 условия - указателят на практика "съдържа" сочения от него елемент и можем да достъпим следващия елемент като го инкрементираме. Именно затова можехме да използваме функциите `std::begin` и `std::end` върху масиви - това са функции, които връщат итератори към първия елемент и след последния елемент на подадената колекция. Ако искаме те да работят и за наши колекции, то те трябва да съдържат методите `begin` и `end` (std::begin и std::end просто извикват методите begin и end).

#### Range-based for loop
В C++ има опростен начин за обхождане на колекции, за които има реализиран итератор - това е т.нар. `range-based for loop`. Той има следния вид:

```c++
int arr[] = {1, 2, 3, 4, 5};

for(int x : arr) {
  std::cout << x << ' ';
}
```

Този вид цикъл всъщност е синтактична захар за следния запис:

```c++
auto begin = std::begin(arr);
auto end = std::end(arr);
for(; begin != end; ++begin) {
int x = *begin;
  std::cout << x << ' ';
}
```

В случая `auto` е типът на итератора, върнат от `std::begin` и `std::end`. От тук вече се вижда, че минималният интерфейс, който трябва да имплементират итераторите на колекциите, така че да могат да бъдат използвани с `range-based for loop` е следният:
- iterator_type& operator++() - служи за достъпване на следващия елемент;
- bool operator!=(const iterator_type& other) const - служи за проверка дали елементите, сочени от 2 итератора са различни;
- \[const\] element_type& operator*() \[const\] - служи за \[константен\] достъп до елемента, сочен от итератора.

Забележка: `iterator_type` и `element_type` не са конкретни типове, а означения съответно за типа на итератора и типа на елементите на обхожданата колекция. Нарочно не са изразени чрез шаблони, защото по-нататък ще видим, че това ще доведе до някои проблеми и особености. 

Освен това, за да работи горния цикъл с нашите колекции, те освен, че трябва да имат съответния итератор, трябва да поддържат и 2 допълнителни метода:
- iterator_type begin() const - връща итератор към първия елемент на колекцията;
- iterator_type end() const - връща итератор след последния елемент на колекцията.

Забележка: за да работи `range-based for loop` за нашите колекции, трябва горните сигнатури на методите да бъдат спазени **точно** - това включва `const` и `&`, където е необходимо.

### Примерна имплементация
https://refactoring.guru/design-patterns/iterator/cpp/example

--- 
#### Задачи за итератори:
1. Подкарайте примера за итератори от линка при вас
2. Създайте итератор `ReverseIterator`, който итерира в обратна посока (от края към началото)

### III.Работа с файлове

1. Видове файлове според типа данни
   - Текстови
   - Двоични

Текстови файлове
: Файлове, в които съдържанието е предназначено за четене от хора. Данните във файла са различни от паметта.

Двоични файлове
: Файлове, които съдържанието е почти точно копие на паметта

2. Видове операции по файлове
   - четене
   - писане
   - четене и писане

Поток
: абстракция с която описваме връзката между програмата и даден файл или устройство

3. Видове потоци
   - потоци за вход (istream)
   - потоци за изход (ostream)

За работа с файлове използваме билбиотеката `<fstream>` или съответните `ifstream` и `ofstream`

![](https://i.sstatic.net/NZ8ST.gif)
<br>
<br>

***Преди работа с какъвто и да е файл той трябва първо да бъде отворен от програмата.***
<br>
***Задължително след отваряне на файл в някакъв момент той трябва да бъде затворен***
<br>

`open` - метод за отваряне на файл
`close` - метод за затваряне на файл
`ifstream` - клас за четене от файл
`оfstream` - клас за писане във файл


1. Флагове
   - `good` 
     : Потокът е в добро състояние. Последната операция е била успешна.
   - `bad` - 
     : Несъвместим с `good`. Възникнала е грешка при последната операция. Например хардуерен проблем
   - `fail` - 
     : Несъвместим с `good`. Пример за този флаг е грешен формат на данните
   - `eof` 
     : Флаг за край на файла. Вдига се при опит за прочитане **след** последния символ. Заедно с него се вдига и `fail`, тъй като данните са невалидни.
   - `clear()`
     : Метод за изчистване на флаговете за грешка. Оставя само флага `good`

*При получаване на флаг за грешка операциите по потока ще бъдат неуспешни и без ефект*

*Добра практика е да се използва `good` флага за условие в цикъл вместо `eof`*

- Методи на `ifstream`
  - \>> - четене на следващото парче данни
  - get - четене на един или повече символи
  - getline - четене на реда

- Методи на `оfstream`
  - \<< - записване на стойността от променливата в потока
  - put - записване на символ в потока


#### Текстови файлове

Пример за четене от текстови файл

```cpp 
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream file("myFile.txt"); // Трябва да съществува такъв файл!!!
	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a, b;

	file >> a >> b;

	file.close();
}
```

<br>
<br>

Пример за писане в текстови файлове
```cpp
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a = 3;
	int b = 10;

	file << a << " " << b << " " << a + b << std::endl;

	file.close();
}
```

Четенето и писането се случва чрез съответно get и put указатели

Позициониране на get и put указателите
 - tellg() - Връща позицията на текущия символ в потока за четене
 - tellp() - Връща позицията на текущия символ в потока за писане
 - seekg(offset, direction) - Премества get-указателят на потока за четене с offset символа в посоката, която е посочена.
 - seekg(streampos idx) - Премества get-указателят на потока за четене на позиция idx.
 - seekp(offset, direction) - Премества put-указателят на потока за писане с offset символа в посоката, която е посочена.
 - seekp(streampos idx) - Премества put-указателят на потока за писане на позиция idx.
  
  
  offset: целочислена стойност. Отместването от direction. 
  direction: Може да заема следите стойности:
 - ios::beg - началото на файла.
 - ios::cur - текущата позиция във файла.
 - ios::end - края на файла.


#### Режими на работа
```cpp
ifstream str("file.txt", <режим на работа>);
```

Режимът на работа е комбинация от флагове
||Ефект|
|-|-|
|ios::app|Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.|
|ios::ate|Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.|
|ios::binary|Превключва режима от текстов в двоичен.|
|ios::in|Отваря файл за четене.|
|ios::out|Отваряне на файл за вмъкване. Допуска се вмъкване на произволни места във файла. Ако файлът съществува, съдържанието се изтрива.|
|ios::trunc|Ако файлът съществува, съдържанието се изтрива.|

Пример
```cpp
ofstream file("file.txt", ios::out | ios::app);
```

#### Двоични файлове

За двоичните файлове използваме следните методи:

- read(char* memoryBlock, size_t size)
- write(const char* memoryBlock, size_t size)

*Важното тук е, че се използват указатели от тип char\* , т.е. нужно е да се преобразуват адресите на променливите до тип char\**


#### Записване на проста структура в двоичен файл

Структура
```cpp
    struct Test{

        bool b;
        int x;

    };
```
<br>
<br>
Записване на структурата Test в двоичен файл

```cpp 
    Test t = { true, 45 };
    std::ofstream file("testObj.bat", std::ios::binary | std::ios::trunc);

    if(!file.is_open()) return -1;

    file.write(reinterpret_cast<const char*>(&t), sizeof(t));

    file.close();
```
<br>
<br>

Четене на структурата Test от двоичен файл
```cpp
    Test t;
    std::ifstream file("testObj.bat", std::ios::binary);
    
    if(!file.is_open()) return -1;

    file.read(reinterpret_cast<char*>(&t), sizeof(t));

    std::cout << t.b << " " << t.x << '\n';

    file.close();
```

<br>
<br>

#### Записване на масив структура от структури с масиви двоичен файл

Структура
```cpp
struct Student{
	char name[24];
	int age;
	int fn;
};
```
<br>
<br>

Записване на структурa Student в двоичен файл

```cpp
void WriteStudent(const Student &student, std::ifstream &file){
    size_t nameSize = strlen(students[i].name);
    file.write(reinterpret_cast<char const *>(&nameSize), sizeof(size_t));
    file.write(students[i].name, nameSize);
    file.write(reinterpret_cast<char const *>(&students[i].age), sizeof(int));
    file.write(reinterpret_cast<char const *>(&students[i].fn), sizeof(int));
}

```
<br>
<br>

Записване на масив от структури Student в двоичен файл

```cpp
void SaveToFile(Student const *students, size_t const count, std::ofstream &file){

	file.write(reinterpret_cast<char const *>(&count), sizeof(size_t));

	for(size_t i = 0; i < count; ++i){
        WriteStudent(students[i],file);
	}

}
```
<br>
<br>

Четене на структурa Student от двоичен файл
```cpp
void ReadStudent(Student &student, std::ifstream &f){
    size_t nameLen;
    f.read(reinterpret_cast<char *>(&nameLen), sizeof(size_t)); // First we read the size of the name!
    f.read(student.name, nameLen);
    student.name[nameLen] = '\0';
    f.read(reinterpret_cast<char *>(&student.fn), sizeof(int));
    f.read(reinterpret_cast<char *>(&student.age), sizeof(int));
    f.read(reinterpret_cast<char *>(&student.fn), sizeof(double));

}

```
<br>
<br>

Четене на масив от структури Student от двоичен файл

```cpp

    Student *ReadFromFile(size_t &studentsCount, std::ifstream &f){

	size_t numberOfStudents;
	f.seekg(0, std::ios::beg);
	f.read(reinterpret_cast<char *>(&numberOfStudents), sizeof(size_t));

	Student *ptr = new(std::nothrow) Student[studentsCount];
	if(!ptr) return nullptr;

	for(size_t i = 0; i < numberOfStudents; ++i) ReadStudent(ptr[i], f);

	return ptr;

}
```

Задачи за текстови файлове:
1. Напишете функция, която приема име на съществуващ файл и име и връща броя на редовете в него.
2. Напишете функция, която приема имената на два текстови файла, в които са записани цели числа в сортиран вид. Числата са разделени с интервал. Запишете в нов файл числата от двата файла в сортиран вид. Числата отново да са разделени с интервал.

----
## Задачи
